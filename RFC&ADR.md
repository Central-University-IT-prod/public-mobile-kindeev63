# Отрисовка UI
## Введение
Отрисовка интерфейса для пользователя один из важнейших функционалов любого Android приложения. Я знаю 2 подхода для реализации UI в Android приложении. Императивный (XML) и Декларативный (Jetpack Compose). В этой части я выберу способ отрисовки UI в LifestyleHub и объясню свой выбор.
## Цель
Определиться с способом реализации пользовательского интерфейса для LifestyleHub.
## Решение
Для разработки этого приложения я решил использовать Jetpack Compose. На это есть 2 причины:
Во-первых Jetpack Compose сейчас активно продвигается Google, поэтому его постоянно дополняют и улучшают (в LifestyleHub в будущем можно будет легче внедрять новые функции и поддерживать старые).
Во-вторых в последнее время я сам работаю на Jetpack Compose, и заметил, что с ним мне гораздо быстрее и удобнее работать, чем с XML. А учитывая, что время на разработку ограниченно, я выбрал более быструю и практичную для меня библиотеку.
## Последствия
С использованием Jetpack Compose я смогу быстро и качественно написать пользовательский интерфейс для LifestyleHub. Этот UI можно будет легко добавлять и поддерживать в будущем. У меня останется больше времени на изучение другого материала, необходимого для реализации приложения и для самой реализации приложения.
## Рассматриваемые альтернативы
В качестве альтернативы я рассматривал использование XML. Но решил остановиться на Jetpack Compose из-за причин изложенных в решении.

# Навигация в приложении
## Введение
После выбора Jetpack Compose для реализации пользовательского интерфейса LifestyleHub мне необходимо решить на какой библиотеке будет реализована навигация в приложении и определиться с структурой навигации. Именно об этом повествуется в этой части.
## Цель
Выбрать библиотеку для навигации и построить структуру навигации в приложении.
## Решение
### Выбор библиотеки
Для реализации навигации я выбрал Jetpack Navigation. С ним я до этого всегда работал для реализации навигации в своих приложениях. У меня имеются заготовленные классы и объекты для навигации с использованием Jetpack Navigation. Ну и конечно же нельзя забывать про ограничение по времени (чтобы не тратить его на изучение других библиотек). Исходя из вышесказанного я и выбрал Jetpack Navigation.
### Структура навигации
Я планирую реализовать 5 экранов в LifestyleHub:
1. Список мест поблизости
2. Подробная информация о месте
3. Список заметок
4. Экран для редактирования заметки
5. Аккаунт (вход, регистрация и информация о пользователе)

Вот все возможные переходы между экранами:
1. Список мест поблизости -> Подробная информация о месте (при нажатии на элемент места в списке)
2. Список заметок -> Экран для редактирования заметки (при нажатии на элемент заметки в списке)
3. Список мест поблизости <-> Список заметок (будет BottomNavigationBar для перехода между ними)
4. Список мест поблизости и Список заметок -> Аккаунт (будет TopBar в котором будет иконка пользователя, при нажатии на которую и будет осуществляется переход)
5. Подробная информация о месте -> Экран для редактирования заметки (в TopBar у экрана с информацией о месте будет кнопка создать заметку, при нажатии на которую создаётся новая заметка, к ней привязывается информация о месте и пользователь переходит на экран для редактирования этой заметки)
6. Экран для редактирования заметки -> Подробная информация о месте (если к заметке привязано место, то слева от названия заметки будет кнопка для перехода на экран с информацией о месте)
## Последствия
Использование Jetpack Navigation оставит мне время на изучения других неизвестных мне тем, а также даст мне возможность быстро и качественно создать навигацию в LifestyleHub.
## Рассматриваемые альтернативы
Для навигации не рассматривал других вариантов реализации.
# Библиотека для работы с Api
## Введение
Важной частью LifestyleHub является получение данных с сервера, основной функционал приложения связан с получением данных с различных api. Поэтому важно выбрать удобный и простой в реализации ahtqvdjhr для получения данных с сервера. Здесь речь идёт именно об этом.
## Цель
Выбрать библиотеку для получения данных с api.
## Решение
Для работы в api я решил использовать Retrofit2. Это простая, понятная и удобная библиотека для получения данных с сервера. Так как я раньше не работал с подобными библиотеками (все мои приложения не совершали обращений к серверам), то мне было важно найти понятную библиотеку, работе с которой можно быстро обучиться. В интернете я сразу натолкнулся на Retrofit2. Узнав о нём поподробнее я понял, что это именно то, что я и искал. Библиотека проста для изучения, и на ней можно быстро писать запросы к api. Приоритетным для меня является простота и время необходимое для изучения, ну и конечно же удобство написания кода. Именно основываясь на этих факторах я и выбрал Retrofit2.
## Последствия
Выбор Retrofit2 позволил мне быстро выучить новую технологию и начать писать запросы к api в тот же день. Я считаю, что выбор именно этой библиотеки оказался верным решением.
## Рассматриваемые альтернативы
Я также рассматривал Ktor и OkHttp, но обе они более сложны для изучения и реализации запросов, поэтому я и не выбрал их.
# Работа с Json
## Введение
После обращения к api я получаю результат в Json формате. Мне необходимо получить из него данные. Здесь я рассказываю какие библиотеки для этого собираюсь использовать.
## Цель
Выбрать библиотеку для работы с Json.
## Решение
В 2 этапе я работал с JSONArray и JSONObject, но обычно я работаю с Gson, так как это простоя удобная библиотека для работы с Json. Чтобы оставить время для изучения других библиотек я остановил свой выбор на ней. Но, так как я не очень хорошо работаю с массивами с помощью Gson, в некоторых местах я буду использовать JSONArray, чтобы получать элементы массива, а потом уже работать с ними с помощью Gson.
## Последствия
Выбор Gson позволит мне быстро написать логику работы с Json ответами от api. Я смогу верно и быстро реализовать эту логику.
## Рассматриваемые альтернативы
Альтернативы не рассматривались.
# Сохранение данных
## Введение
Для сохранения кэша и информации о пользователях я должен буду реализовать локальную базу данных, в которую эта информация и будет записываться. В этой части я рассказываю об этом.
## Цель
Выбрать способ хранения данных локально на смартфоне пользователя.
## Решение
В этом приложении я буду использовать Room Database, так как она является основной библиотекой для создания базы данных для Android. Я уже раньше работал с ней и у меня есть заготовки для создания базы данных при помощи Room Database. Для сохранения текущего логина и пароля пользователя я буду использовать SharedPreferences , потому что сохранять нужно всего две строчки и писать громоздкий код для этого я не планирую. И с помощью SharedPreferences как раз можно используя минимум кода сохранить небольшую информацию.
## Последствия
Реализовав базу данных с помощью Room Database я быстро создам структурированное хранилище объектов на смартфоне пользователя. А используя SharedPreferences для сохранения логина и пароля я сохраню время (кода писать придётся меньше).
## Рассматриваемые альтернативы
Рассматривал сохранение текущего логина и пароля пользователя при помощи Proto DataStore и Room Database, но не выбрал их из-за большего количества кода, которого мне придётся писать.
# Использование собственного DatePickerDialog
## Введение
В LifestyleHub я использовал собственную реализацию DatePickerDialog, вместо стандартной. Причины этого я описываю здесь.
## Цель
Рассказать о причинах использования собственной реализации DatePickerDialog в  LifestyleHub.
## Решение
Когда я только начинал изучать Jetpack Compose не было реализации DatePickerDialog с помощью Jetpack Compose. В какой-то момент мне понадобился DatePickerDialog, но использовать стандартный (не из Compose) я не хотел. Поэтому я создал свою реализацию DatePickerDialog с использованием Jetpack Compose. Эта реализация наиболее удобна для меня, и я прекрасно с ней знаком, поэтому и решил использовать её в LifestyleHub.
## Последствия
Я смог быстро добавить DatePickerDialog в LifestyleHub не заморачиваясь изучением добавления стандартного DatePickerDialog, что сэкономило мне время на реализацию остальных функций этого приложения.
## Рассматриваемые альтернативы
Рассматривал использование стандартного DatePickerDialog, но отказался по причинам, изложенным в решении и последствиях.
# Шифрование паролей пользователей
## Введение
Перед сохранением пользователей в базу данных я хочу шифровать их пароли. В этой части я рассказываю о выборе библиотеки для этого.
## Цель
Выбрать библиотеку для шифрования паролей пользователей.
## Решение
Для реализации шифрования паролей пользователей я выбрал Cipher так как он является предустановленным и простым в изучении и работе.
## Последствия
С помощью Cipher я быстро реализовал шифрование паролей для пользователей перед сохранением их в базу данных.
## Рассматриваемые альтернативы
Альтернатив не рассматривал.
# Получение геолокации пользователя
## Введение
Для получения информации о погоде и местах поблизости мне необходимо узнавать текущую геолокацию пользователя. О том как я планирую это реализовать рассказываю здесь.
## Цель
Выбрать метод получения геолокации пользователя.
## Решение
Для этой цели я буду использовать Play Services Location. Это библиотека от Google для получения последней известной геолокации пользователя. Она проста в освоении и с её помощью легко реализовать получение последней известной геолокации пользователя. Этот способ очень легко интегрируется с Jetpack Compose. Эта библиотека не нагружает батарею пользователя. Она является предпочтительным способом получения геолокации пользователя.
## Последствия
Я смог реализовать получение геолокации пользователя, тратя минимум ресурсов устройства.
## Рассматриваемые альтернативы
Не рассматривал других вариантов.
# Получение Permissions
## Введение
Мне необходимо было получать permission ACCESS_FINE_LOCATION. При этом настроить интеграцию с Jetpack Compose. В этой части рассказываю как я это реализовал.
## Цель
Реализовать получение permission ACCESS_FINE_LOCATION и использование результата в Composable функции.
## Решение
Мой выбор пал на библиотеку accompanist-permissions. Она позволяет получать permissions внутри Composable функций, что мне и было необходимо. Это удобная библиотека, решающая множество проблем с получением permissions с использованием Jetpack Compose (стандартный метод предполагает использование activity, но я не хочу передавать лишние данные с activity в мои Composable функции).
## Последствия
Используя библиотеку accompanist-permissions я реализовал получение permission ACCESS_FINE_LOCATION, что позволило мне получить местоположение пользователя.
## Рассматриваемые альтернативы
Рассматривал использование стандартного метода с Activity и стандартного launcher для permissions в Compose. Первый не подошёл по причинам, указанным в решении, а второй не всегда корректно отрабатывал (не выходило получать permission при старте приложения)
# Получение изображения по Url
## Введение
Во многих местах LifestyleHub мне необходимо показывать пользователю изображение полученное с url. Здесь рассказываю как я собираюсь это реализовать.
## Цель
Реализовать показ изображения с url пользователю.
## Решение
Я воспользовался библиотекой landscapist-glide, а конкретно Composable функцией GlideImage из этой библиотеки. Библиотека предоставляет отличные возможности для демонстрации изображения по ссылке. в функции GlideImage очень много передаваемых аргументов, можно очень гибко настроить Отображение изображения.
## Последствия
Я настроил отображение изображений по ссылкам в LifestyleHub очень быстро, пришлось писать малое количество кода, и результат меня полностью устраивает.
## Рассматриваемые альтернативы
Рассматривал Glide, Coil и Picasso, ни одна из данных библиотек не может похвастаться весомыми преимуществами перед landscapist-glide. Реализации в этих библиотеках мне понравились меньше чем в выбранной landscapist-glide. Поэтому я и не выбрал Glide, Coil и Picasso.
# Показ фотографий места
## Введение
На экране с подробной информацией о месте (в его верхней части) должен быть элемент с фотографиями из этого места. В это части расскажу про его реализацию.
## Цель
Реализовать элемент с фотографиями места.
## Решение
Для реализации этого элемента я добавил в проект библиотеки accompanist-pager и accompanist-pager-indicators. С их помощью можно реализовать ViewPager и индикатор для него (важнее всего был именно индикатор, так как стандартный HorizontalPager не позволял добавлять индикатор). Чем я и занялся. Я решил брать только 10 фотографий места (так-как получение большого числа изображений будет сильно нагружать устройство).
## Последствия
Реализовал HorizontalPager с 10 фотографиями места и индикатор к нему. Получилось довольно красиво и быстро.
## Рассматриваемые альтернативы
Рассматривал получение и показ всех фотографий места, но отбросил этот вариант из-за сильной нагрузки на устройство.
# Тесты
## Введение
Здесь рассказываю как я писал тесты.
## Цель
Решить, как и с помощью какой библиотеки я буду писать тесты.
## Решение
Свой выбор я остановил на junit. Так как это небольшая, но очень удобная библиотека для написания тестов (в том числе и UI тестов).
## Последствия
С помощью junit, я быстро смог написать тексты для LifestyleHub, не сильно углубляясь в саму библиотеку.
## Рассматриваемые альтернативы
Рассматривал Espresso, но с ней оказалось труднее работать, поэтому выбрал более простой junit
# LiveData или Flow
## Введение
При работе с Jrtpack Compose можно использовать Flow и LiveData. Тут рассказываю что я выбрал и почему.
## Цель
Выбрать что я буду использовать в LifestyleHub: LiveData или Flow.
## Решение
Выбрать я решил LivaData. С ней у меня уже есть опыт работы и я могу быстро написать необходимую часть именно с помощью этой библиотеки. Flow является прекрасным замещением LiveData, но с ним работать немного труднее (да и непривычнее). Время на написание LifestyleHub ограниченно, поэтому я постараюсь использовать знакомые мне технологии для ускорения этого процесса, так как мне всё равно придётся обучаться работе с другими, неизвестными мне библиотеками.
## Последствия
Выбрав LiveData я смог очень быстро реализовать необходимый мне функционал. Мне не пришлось тратить время на изучение Flow, и я успел обучиться работать с другими, необходимыми для создания LifestyleHub, библиотеками.
## Рассматриваемые альтернативы
Рассматривал использование Flow. Но решил остановиться на LiveData. Причина указана в решении.
# MVVM
## Введение
В некоторых местах LisestyleHub я использовал MVVM, добавлял ViewModel для реализации в ней логики приложения. В этой части рассказываю почему я выбрал именно MVVM.
## Цель
Рассказать почему я выбрал MVVM.
## Решение
Я выбрал паттерн MVVM по этим причинам:
1. Раньше я не использовал других паттернов разработки, а с MVVM немного знаком.
2. В интернете я нашёл кучу обучающих материалов по MVVM, чего не скажешь, например, про MVI.
3. MVVM простой в реализации паттерн, также он очень удобен.
   при работе с ViewModels я использовал такие библиотеки как: Lifecycle ViewModel Compose и Runtime Livedata, чтобы интегрировать ViewModel и LiveData в Jetpack Compose.
## Последствия
С помощью MVVM я быстро реализовал логику моего приложения, используя ViewModels.
## Рассматриваемые альтернативы
Рассматривал использование MVI, так как слышал, что он более предпочтителен для разработки с Jetpack Compose. Но остановился на MVVM, так как не нашёл понятной информации по MVI (если поискать подольше то найду, чем я и займусь после написания LifestyleHub, но при написания текущего приложения у меня нет достаточного количества времени на поиск информации и изучение MVI).